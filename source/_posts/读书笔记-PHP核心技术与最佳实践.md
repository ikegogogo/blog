---
title: 读书笔记-PHP核心技术与最佳实践
date: 2019-07-13 23:59:40
tags:
- php
- 读书笔记
---

# 面向对象思想的核心概念

##### 异常与错误处理

PHP里面，遇到任何自身错误都会触发一个错误，而不是抛出异常，PHP遇到非正常代码，通常会触发错误，而不是抛出异常，所以这种错误是不能用异常捕获的。 **PHP只有手动抛出异常后才能捕获。**

##### PHP中的错误处理机制

php错误有很多种：warning,notice,deprecated,fatal error。PHP无法自动抛出异常，必须手动进行，可以用set\_error\_handler接管，进而主动抛出异常。

# 面向对象的设计原则

###### 单一职责原则

single responsibility principle,SRP

就一个类而言，应该只有一个引起它变化的原因。

避免相同的职责分散到不同的类中，避免一个类承担太多职责



##### 接口隔离原则

interface segregation principle,ISP

客户端不应该依赖它不需要的接口

类间的依赖关系应该建立在最小的接口上

##### 开放-封闭原则

open-close principle，OCP

open for extension，模块的行为必须是开放的，支持扩展的，而不是僵化的

close for modification，在对模块的功能进行扩展是，不应该影响或大规模地影响已有的模块

##### 里氏替换原则

Liskov Substitution Principle，LSP

子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方

##### 依赖倒置原则

上层模块不应该依赖于下层模块，它们共同依赖于一个抽象

抽象不能依赖于具体，具体应该要依赖于抽象

# 正则表达式基础与应用



# PHP网络技术及应用

HTTP（Hyper Text Transfer Protocol，超文本传输协议），是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP通常承载于TCP协议之上（80端口），有时也承载于TLS或SSL协议层之上（HTTPS，443端口）。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求没有对应关系。

##### HTTP协议是如何工作的

客户端发送一个请求（request）个服务器，服务器在接受到这个请求后将生成一个响应（response）返回给客户端。一次HTTP操作称为一个食物，其工作过程可分为4步。

1. 客户机于服务器需要建立连接，单击某个超链接，http协议的工作开始
2. 客户机发送一个请求给服务器
3. 服务器接到请求后，给予响应的响应信息
4. 客户端接受服务器返回的信息并显示在用户的显示屏上，然后客户机于服务器断开连接

###### 请求

请求由3部分组成：请求行，消息报头，请求正文

请求行： Method Request-URI HTTP-Version CRLF

###### 响应

响应也由3部分组成：状态行，消息报头，响应正文

状态行：HTTP-Version Status-Code Reasion-Phrase CRLF

###### 报头

普通报头、请求报头、响应报头、实体报头

Host

User-Agent

Accept

Cookie

Set-Cookie

Cache-Control

Referer

Content-Length

Accept-Encoding

###### HTTP应用，模拟灌水机器人

1. cURL库
2. file\_get\_contents
3. socket系列函数
4. 等等

###### 垃圾请求防御

1. IP限制（ip无法伪造）
2. 验证码
3. Token和表单
4. 审核机制

cURL步骤

1. 初始化 $ch = curl\_init()
2. 设置选项，包括URL  curl\_setopt($ch, CURLOPT\_URL, &quot;[http://www.php.net](http://www.php.net)&quot;)
3. 执行并获取HTML文档内容 $out = curl\_exec($ch)
4. 释放curl句柄 curl\_close()

###### Cookie于Session问答

1. cookie运行在客服端，session运行在服务器端，对吗？ 不完全对，cookie运行在客户端，由客户端进行管理，session虽然运行在服务端，但是sessionId最为一个cookie是存储在客户端的
2. 浏览器禁止cookie，cookie就不能用了，但session不会受浏览器影响，对吗？错。会影响，可通过URL传递session
3. 浏览器关闭后，cookie和session都消失了，对吗？错
4. session比cookie安全吗？错误

# PHP与数据库基础

pdo：php data objects，提供一个通用结构访问多种数据库，即抽象的数据模型支持连接多种数据库

事务的主要特性：

1. 原子性
2. 一致性
3. 独立性
4. 持久性

原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。

持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

###### 数据库应用优化

数据库优化的思路：

避免在列上运算，会导致索引失效

使用join是，应该用小结果集驱动大结果集

注意like模糊查询的使用，避免%%

列出需要查询的字段，节省内存

使用批量插入语句节省交互

limit的技术比较大时使用between

不要使用rand函数获取多条随机记录

避免使用null

不要count(id)，而应该是count(\*)

1）应尽量避免在 where 子句中使用!=或\&lt;\&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。

2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

select id from t where num is null

可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

select id from t where num=0

3）很多时候用 exists 代替 in 是一个好的选择

4）用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤

禁止使用select \*、like %xxx

避免使用复杂的sql（不利于理解、优化和缓存）

不要在where索引字段上使用函数、变量、进行数学运算、（索引可能无法使用）

Or &amp; in 优先使用in

不要使用负向查询（not in、not like）

注意limit的效率

避免让mysql做复杂的数学运算

小心地使用trigger和store procedure

Explain select，尽量让where、group by、order by使用索引（最好是主键索引）

Update和delete改为select后explain看执行计划

视情况使用exist代替in

表连接注意连接顺序，用小表连大表，不要大表连小表

用到临时表的sql使用前注意查看db对临时表大小的限制(tmp\_table\_size)

用到文件排序时注意查看排序缓冲大小(sort\_buffer\_size)

不要在引擎不同的表上执行事务

数据库结构优化:

1）范式优化： 比如消除冗余（节省空间。。） 2）反范式优化：比如适当加冗余等（减少join） 3）拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。

4）拆分其实又分垂直拆分和水平拆分： 案例： 简单购物系统暂设涉及如下表： 1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺

方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)

###### 存储引擎的选择

MyISAM: R/W \&gt; 100:1且update相对较少

并发不高，不需要事务

表数据量小

硬件资源有限

InnoDB：R/W较小，频繁更新大字段

表数据量超过1000w，并发高

安全性可可用性要求高

mysql瓶颈及应对措施

1. 增加mysql配置中的buffer和cache的数值
2. 使用第三方引擎或衍生版本
3. 迁移到其他数据库
4. 对数据库进行分区、分表操作，减少单表体积
5. 使用nosql等辅助解决方案，如memchched，redis
6. 使用中间件做数据拆分和分布式部署，如阿里巴巴的cobar
7. 使用数据库连接池技术

###### 范式与反范式

1. 核心业务使用范式
2. 若一致性需求-反ACID  原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
3. 空间换时间，冗余换效率
4. 避免不必要的冗余